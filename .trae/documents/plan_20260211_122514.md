# Agent 消息存储实现计划

本计划旨在创建一个名为 `agent_message` 的新表，用于专门存储 Agent 模式下的会话数据，包括思考过程（thought）、行动（action）等详细信息。

## 1. 数据库变更

*   **创建新表 `agent_message`**：
    *   `id` (BIGINT, PK, Auto Increment)
    *   `user_id` (BIGINT, Not Null) - 关联用户
    *   `session_id` (BIGINT, Not Null) - 关联会话（复用现有的会话 ID 体系）
    *   `role` (VARCHAR, Not Null) - "user" 或 "agent"
    *   `content` (TEXT) - 用户输入或 Agent 的最终回答
    *   `thought` (TEXT) - Agent 的思考过程（JSON 格式或纯文本）
    *   `action` (VARCHAR) - 调用的工具名称
    *   `action_input` (TEXT) - 工具调用参数
    *   `observation` (TEXT) - 工具执行结果
    *   `create_time` (DATETIME)

*   **更新 SQL 脚本**：修改 `sql/create_table.sql` 以包含新表的定义。

## 2. 后端代码开发 (Java)

*   **实体类 (`model/entity`)**：创建 `AgentMessage.java`，映射新的数据库表。
*   **Mapper (`mapper`)**：创建 `AgentMessageMapper.java` (MyBatis Plus)。
*   **Service (`service`)**：创建 `AgentMessageService.java` 和 `AgentMessageServiceImpl.java`。
    *   实现 `saveAgentMessage` 方法。
    *   实现 `listAgentMessages` 方法。
*   **Controller (`controller`)**：
    *   创建 `AgentMessageController.java`。
    *   提供 `POST /agent/message` 用于保存消息。
    *   提供 `GET /agent/message/list` 用于获取历史记录。
*   **适配 `KoneManus`**：修改 `KoneManus.java` 或 `AgentController`，在流式输出结束时异步保存完整的 Agent 执行记录。

## 3. 前端代码适配 (Vue.js)

*   **API (`api/agentApi.js`)**：新增 `agentApi.js`，封装保存和获取 Agent 消息的请求。
*   **App.vue / ChatMessage.vue**：
    *   更新前端逻辑，当处于 Agent 模式时，从新的 API 获取历史记录。
    *   在接收到 SSE 完成信号或手动发送消息时，调用新的保存接口。

## 4. 执行步骤

1.  **数据库**：执行建表 SQL。
2.  **后端**：生成 Entity, Mapper, Service, Controller。
3.  **验证**：通过 Postman 或 Swagger 测试新接口。

